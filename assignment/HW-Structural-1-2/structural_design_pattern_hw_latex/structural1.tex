%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% QUESTION 1 (12 points)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\question[12] We have an application thatsss manages and displays data about various kinds of rock formations. The application takes the information from several databases using their APIs. Each database has a different API, which makes our application unnecessarily complicated. We do not want to pollute the code with conditionals that select the right method signature whenever we need to access one of the databases.

Our application makes the following method calls.
\begin{itemize}[label={}]
    \item \begin{minted}{Java} 
public String fetchRockName();
\end{minted} 
    \item \begin{minted}{Java} 
public String fetchRockType();
    \end{minted}
    \item \begin{minted}{Java} 
public String fetchRockLocation();
    \end{minted}
    \item \begin{minted}{Java} 
public Iterator<String> details();
    \end{minted}
\end{itemize}

Three of the database services provide these methods.
However, one database service provides the methods getName(), getType(), getAge(), getComposition(),getLocation(), and getFeatures(). All of these methods return String. 
Another one provides: rname(), rtype(), rloc(), age(), rdetail().  All of these methods return String except rdetail() returns a list of Strings.
Suggest a structural design pattern to make our application work with these database services without conditional statements to select the right method name.
(address all items 1-5)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% YOUR ANSWER HERE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{enumerate}
    \item Adapter Pattern
    
    \item Adaptor pattern is to convert the interface of one class to another, so that incompatible interfaces can work together. In this case:

    \begin{itemize}
        \item Adaptee → the class that already exists but has an incompatible interface. one service has methods like getName(), getType(), etc., while another service has methods like rname(), rtype(), etc.)
        \item Adapter → the new classes to translate the adaptee’s API into the interface client expects.
       \item Target → the existing interface
        \item Client → the application
    \end{itemize}
    
    \item Show you design with a UML class diagram. 
    
    See attachment "adaptor-rock-application.drawio.pdf"
    
    
    \item Give Java or C++ code for your design showing how you have implemented the pattern. 

\begin{minted}{Java} 

// Target Interface
public interface IRockDataSource {
    String fetchRockName();
    String fetchRockType();
    String fetchRockLocation();
    Iterator<String> details();
}

public class StandardDBOne implements IRockDataSource {
    public String fetchRockName() { return "StandardDBOne name"; }
    public String fetchRockType() { return "StandardDBOne type"; }
    public String fetchRockLocation() { return "StandardDBOne location"; }
    public Iterator<String> details() {
        return Arrays.asList("string", "string").iterator();
    }
}

public class StandardDBTwo implements IRockDataSource {
    public String fetchRockName() { return "StandardDBTwo name"; }
    public String fetchRockType() { return "StandardDBTwo type"; }
    public String fetchRockLocation() { return "StandardDBTwo location"; }
    public Iterator<String> details() {
        return Arrays.asList("string", "string").iterator();
    }
}

public class StandardDBThree implements IRockDataSource {
    public String fetchRockName() { return "StandardDBThree name"; }
    public String fetchRockType() { return "StandardDBThree type"; }
    public String fetchRockLocation() { return "StandardDBThree location"; }
    public Iterator<String> details() {
        return Arrays.asList("string", "string").iterator();
    }
}

// Incompatible service #1
class IncompatibleDBOne {
    public String getName() { return "IncompatibleDBOne getName"; }
    public String getType() { return "IncompatibleDBOne getType"; }
    public String getAge() { return "IncompatibleDBOne getAge"; }
    public String getComposition() { return "IncompatibleDBOne getComposition"; }
    public String getLocation() { return "IncompatibleDBOne getLocation"; }
    public String getFeatures() { return "IncompatibleDBOne getFeatures"; }
}

calss IncompatibleDBOneAdaptor implements IRockDataSource {
    private IncompatibleDBOne incompatibleDB;
    public IncompatibleDBOneAdaptor(IncompatibleDBOne dbService){
        this.incompatibleDB = dbService;
    }

    @Override
    public String fetchRockName() { return incompatibleDB.getName(); }

    @Override
    public String fetchRockType() { return incompatibleDB.getType(); }

    @Override
    public String fetchRockLocation() { return incompatibleDB.getLocation(); }

    @Override
    public Iterator<String> details() {
        return Arrays.asList(
            incompatibleDB.getAge(), 
            incompatibleDB.getComposition(), 
            incompatibleDB.getFeatures(), 
            ).iterator();
    }
}

// Incompatible service #2
class IncompatibleDBTwo {
    public String rname() { return "IncompatibleDBTwo rname"; }
    public String rtype() { return "IncompatibleDBTwo rtype"; }
    public String rloc() { return "IncompatibleDBTwo rloc"; }
    public String age() { return "IncompatibleDBTwo age"; }
    public List<String> rdetail() {
        return Arrays.asList("string", "string");
    }
}

calss IncompatibleDBTwoAdaptor implements IRockDataSource {
    private IncompatibleDBTwo incompatibleDB;
    public IncompatibleDBTwoAdaptor(IncompatibleDBTwo dbService){
        this.incompatibleDB = dbService;
    }

    @Override
    public String fetchRockName() { return incompatibleDB.rname(); }

    @Override
    public String fetchRockType() { return incompatibleDB.rtype(); }

    @Override
    public String fetchRockLocation() { return incompatibleDB.rloc(); }

    @Override
    public Iterator<String> details() { 
        return incompatibleDB.rdetail().iterator();
    }
}

public class Main {
public static void main(String[] args) {
        List<RockDataSource> sources = Arrays.asList(
            new StandardDBOne(),
            new StandardDBTwo(),
            new StandardDBThree(),
            new IncompatibleDBOneAdaptor( new IncompatibleDBOne() ),
            new IncompatibleDBTwoAdaptor( new IncompatibleDBTwo() ),
        );

        for (RockDataSource src : sources) {
            System.out.println("Rock: " + src.fetchRockName());
            System.out.println("Type: " + src.fetchRockType());
            System.out.println("Location: " + src.fetchRockLocation());
            System.out.println("Details: ");
            src.details().forEachRemaining(System.out::println);
        }
    }
}
\end{minted}



    \item Evaluate your design with respect to SOLID principles. 
\end{enumerate}

\begin{itemize}
    \item Single Responsibility Principle: Every adapter has only one responsibility.
    \item Open-Closed Principle: New adapters can be added in the future without modifying existing logic
    \item Liskov Substitution Principle: N/A
    \item Interface Segregation Principle: Client only depends on `IRockDataSource`, which only contains the necessary methods
    \item Dependency Inversion Principle: client depends on the abstraction (RockDataSource) rather than concrete classes
\end{itemize}






